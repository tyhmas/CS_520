import java.awt.Color;
import java.util.*;

enum State {
	UNKNOWN, SAFE, MINE, TRIGGER;
}

class Cell {
	int x;
	int y;
	State state;
	Color color;
	int mineNum;
	int p;
}

public class SweepMineAI {
	private int size;
	private int mineNumber;
	
	private int remainMineCounter;
	private int unknownCounter;

	private Cell[][] sweepMap;
	private PriorityQueue<Cell> decisionSet;

	private MineField mineField;

	class pComparator implements Comparator<Cell> {
		public int compare(Cell c1, Cell c2) {
			return c1.p - c2.p;
		} 
	}

	SweepMineAI(MineField mineField) {
		this.mineField = mineField;
		this.size = mineField.getSize();
		
		mineNumber = mineField.getMineNum();

		remainMineCounter = mineField.getMineNum();
		unknownCounter = size*size;		

		decisionSet = new PriorityQueue<Cell>(size*size, new pComparator());

		sweepMap = new Cell[size][size];
		for (int ii = 0; ii < size; ++ii) {
			for (int jj = 0; jj < size; ++jj) {
				sweepMap[ii][jj] = new Cell();
				sweepMap[ii][jj].x = ii;
				sweepMap[ii][jj].y = jj;
				sweepMap[ii][jj].color = Color.WHITE;
				sweepMap[ii][jj].mineNum = -1;
				sweepMap[ii][jj].p = (int) (4*200 + mineNumber*100 / (size*size));
				System.out.println("p " + sweepMap[ii][jj].p);
				sweepMap[ii][jj].state = State.UNKNOWN;
				decisionSet.add(sweepMap[ii][jj]);
			}
		}
	}

	private boolean mineSolver(int x, int y) {
		int up = 0;

		/*
		 * Deterministic Part
		 * 
		 */
		while (!decisionSet.isEmpty()) {

			up = (int) (4*200 + remainMineCounter*100 / (size*size));
			for (int u = 0; u < size; ++u) {
				for (int v = 0; v < size; ++v) {
					if (sweepMap[u][v].state == State.UNKNOWN && sweepMap[u][v].p > up)
						sweepMap[u][v].p = up;
				}
			}

			x = decisionSet.peek().x;
			y = decisionSet.peek().y;

			decisionSet.poll();

			int surCount = 0;
		    int lowX = x - 1;
		    lowX = lowX < 0 ? 0 : lowX;
		    int highX = x + 2;
		    highX = highX > size ? size : highX;

		    int lowY = y - 1;
		    lowY = lowY < 0 ? 0 : lowY;
		    int highY = y + 2;
		    highY = highY > size ? size : highY;

			if (mineField.isBomb(x, y) == false) {
				// Lucy!
				sweepMap[x][y].mineNum = mineField.countSurroundingMines(x, y);
				sweepMap[x][y].state = State.SAFE;
				--unknownCounter;
				//decisionSet.remove(sweepMap[x][y]);
				System.out.println("current " + " x = " + x + " y = " + y);
			} else {
				// Boom!
				sweepMap[x][y].state = State.TRIGGER;
				return false;
			}

		    int mine = 0, safe = 0;
		    for (int ii = lowX; ii < highX; ii++) {
		        for (int jj = lowY; jj < highY; jj++) {
					if (ii != x || jj != y) {
						++surCount;
						if (sweepMap[ii][jj].state == State.SAFE)
							++safe;
						if (sweepMap[ii][jj].state == State.MINE)
							++mine;
					}
		        }
		    }
			// System.out.println("***" + surCount);

			if ((surCount - safe) == sweepMap[x][y].mineNum) {
				// Able to etermine Mines
				for (int ii = lowX; ii < highX; ii++) {
				    for (int jj = lowY; jj < highY; jj++) {
						if ((ii != x || jj != y) && (sweepMap[ii][jj].state != State.SAFE && sweepMap[ii][jj].state != State.MINE)) {
							sweepMap[ii][jj].state = State.MINE;
							--remainMineCounter;
							--unknownCounter;
							decisionSet.remove(sweepMap[ii][jj]);
							System.out.println("*** Cur " + x + " " + y);
							System.out.println("*** Mine " + ii + " " + jj);
						}
				    }
				}			 
			} else if ((surCount - safe) > sweepMap[x][y].mineNum) {
				if (sweepMap[x][y].mineNum == mine) {
					System.out.println("wahaha");
					for (int ii = lowX; ii < highX; ii++) {
						for (int jj = lowY; jj < highY; jj++) {
							if ((ii != x || jj != y) && (sweepMap[ii][jj].state != State.SAFE && sweepMap[ii][jj].state != State.MINE)) {
								if (sweepMap[ii][jj].p > 0 + 200 * sweepMap[x][y].mineNum) {
									if (decisionSet.contains(sweepMap[ii][jj]))
										decisionSet.remove(sweepMap[ii][jj]);
									sweepMap[ii][jj].p = 0 + 200 * sweepMap[x][y].mineNum;
									decisionSet.add(sweepMap[ii][jj]);
									System.out.println("gailv " + sweepMap[ii][jj].p + " ii = " + ii + " jj = " + jj);
								}
							}
						}
					}
				} else if (sweepMap[x][y].mineNum > mine) {
					for (int ii = lowX; ii < highX; ii++) {
						for (int jj = lowY; jj < highY; jj++) {
							if ((ii != x || jj != y) && (sweepMap[ii][jj].state != State.SAFE && sweepMap[ii][jj].state != State.MINE)) {
								int tmp = (int)((sweepMap[x][y].mineNum - mine)*100 / (surCount-safe-mine) + 200*sweepMap[x][y].mineNum);
								//System.out.println("tmp = " + tmp + " cur p = " + sweepMap[ii][jj].p);
								if (tmp < sweepMap[ii][jj].p) {
									if (decisionSet.contains(sweepMap[ii][jj]))
										decisionSet.remove(sweepMap[ii][jj]);
									sweepMap[ii][jj].p = tmp;
									decisionSet.add(sweepMap[ii][jj]);
									System.out.println("gailv " + sweepMap[ii][jj].p + " ii = " + ii + " jj = " + jj);
								}
							}
						}
					}			
				} else {
					System.out.println("error1");
				}
			} else {
				System.out.println("error2");
			}

			System.out.println("" + decisionSet.size());

			if (unknownCounter == remainMineCounter) {
				System.out.println("nitamashibushishabi " + unknownCounter + " " + remainMineCounter);
				for (int ii = 0; ii < size; ++ii) {
					for (int jj = 0; jj < size; ++jj) {
						if (sweepMap[ii][jj].state == State.UNKNOWN) {
							if (remainMineCounter != 0) {
								sweepMap[ii][jj].state = State.MINE;
								--remainMineCounter;
							} else {
								sweepMap[ii][jj].state = State.SAFE;
							}
						}
					}
				}
				return true;
			}

		}

		// Cell candidate = decisionSet.peek();
		//return mineSolver(decisionSet.peek().x, decisionSet.peek().y);
		return true;
	}

	public Cell[][] sweepMine() {
		/*int start = new Random().nextInt(3);
		switch (start) {
			case 0:
				decisionSet.add(sweepMap[0][0]);
				mineSolver(0, 0);
				break;
			case 1:
				decisionSet.add(sweepMap[0][size-1]);
				mineSolver(0, size-1);
				break;
			case 2:
				decisionSet.add(sweepMap[0][size-1]);
				mineSolver(size-1, 0);
				break;
			case 3:
				decisionSet.add(sweepMap[0][size-1]);
				mineSolver(size-1, size-1);
				break;
		}*/

		//decisionSet.add(sweepMap[0][0]);
		mineSolver(0, 0);

		return sweepMap;
	}



}
